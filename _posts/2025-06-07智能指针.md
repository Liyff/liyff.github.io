# 智能指针





![image-20250728221438899](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250728221438899.png)

**RAII**（Resource Acquisition Is Initialization）是一种利用对象生命周期来控制程序资源

在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的
时候释放资源



C++98	auto_ptr    管理权转移

C++11 unique_ptr   防拷贝

C++11  shared_ptr   引用计数     

C++11  weak_ptr      专门解决shared_ptr循环引用问题，没有RAII资源管理机制，严格来说不是智能指针

```c++
//auto_ptr 管理权转移
template<class T>
class auto_ptr {

	auto_ptr(T* ptr = nullptr)
		:_prt(ptr)
	{
	}

	~auto_ptr() {
		if (_ptr) {
			cout << "delete:" << _ptr << endl;
			delete _ptr;
			_ptr = nullptr;
		}
	}

	auto_ptr( auto_ptr<T>& ap)
		:_ptr(ap._ptr)
	{
		ap._ptr = nullptr;
	}

	//ap1 = ap2
	auto_ptr<T>& operator=(auto_ptr<T>& ap) {
		//检查是否自己给自己赋值
		if (this != &ap) {
			if (_ptr) {
				delete _ptr;
			}
			//转移ap中资源到当前对象中
			_prt = ap._ptr;
			ap._ptr = nullptr;
		}
		return *this;
	}

	T& operator*() {
		return *_ptr;
	}

	T* operator->() {
		return _ptr;
	}



private:
	T* _ptr;
};
```



```c++
//unique_ptr 防拷贝
template<class T>
class unique_ptr {

	unique_ptr(T* ptr = nullptr)
		:_ptr(ptr)
	{ }

	~unique_ptr()
	{
		if (_ptr) {
			delete _ptr;
		}
	}

	T& operator*() {
		return *_ptr;
	}
	T* operator->() {
		return _ptr;
	}
private:
	//C++11 防拷贝
	unique_ptr(const unique_ptr<T>&) = delete;
	unique_ptr& operator=(const unique_ptr<T>&) = delete;

private:	
	T* _ptr;
};
```



```c++
//shared_ptr 引用计数的方式管理共享资源
template<class T>
class shared_ptr {
c
public:

	shared_ptr(T* ptr = nullptr)
		:_ptr(ptr),
		_count(1),
		_pmux(new mutex)
	{ }

	~shared_ptr() {
		
		Release();
	}

	void add_count() {
		_pmux->lock();
		++(*_count);
		_pmux->unlock;
	}

	shared_ptr(shared_ptr<T>& sp) 
		:_ptr(sp._ptr),
		_count(sp._count),
		_pmux(sp._pmux)

	{
		add_count();
	}

	//sp1=sp2
	shared_ptr<T>& operator=(shared_ptr<T>& sp) {

		//if (this != &sp)
		if(_ptr! = sp._ptr){
			//释放旧资源
			Release();

			//共享新资源，增加引用计数
			_ptr = sp._ptr;
			_count = sp._count;
			_pmux = sp._pmux;

			add_count();

		}

	}

	T& operator*() {
		return *_ptr;
	}
	T* operator->() {
		return _ptr;
	}

	void Release() {

		bool flag = false;

		_pmux.lock();
		if (--(*_count) == 0) {
			delete _ptr;
			delete _count;
			flag = true;
		}
		_pmux.unlock();

		if (flag == true) {
			delete _pmux;
		}

	}


private:
	T* _ptr;
	int* _count;//引用计数
	mutex* _pmux;//互斥锁
};
```





![image-20250730235547209](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250730235547209.png)

![image-20250730235530377](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250730235530377.png)

### 扩展

用来设计守卫锁，防止异常安全导致的死锁问题

```c++
// C++11的库中也有一个lock_guard，下面的LockGuard造轮子其实就是为了学习他的原理
template<class Mutex>
class LockGuard
{
public:
 	LockGuard(Mutex& mtx)
     :_mutex(mtx)          //锁不允许拷贝
     {
     	_mutex.lock();
     }
     ~LockGuard()
     {
     	_mutex.unlock();
     }
 LockGuard(const LockGuard<Mutex>&) = delete;
private:
     // 注意这里必须使用引用，否则锁的就不是一个互斥量对象
     Mutex& _mutex;
};
    mutex mtx;
    static int n = 0;
void Func()
{
    for (size_t i = 0; i < 1000000; ++i)
    {
         LockGuard<mutex> lock(mtx);
         ++n;
 	}
}

int main()
{
     int begin = clock();
     thread t1(Func);
     thread t2(Func);
     t1.join();
     t2.join();
     int end = clock();
     cout << n << endl;
     cout <<"cost time:" <<end - begin << endl;

     return 0;
}


```

