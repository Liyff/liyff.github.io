# 特殊类的设计

### 1请设计一个类，只能在堆上创建对象

```c++
class HeapOnly 
{ 
public: 
     static HeapOnly* CreateObject() 
     { 
     	return new HeapOnly; 
     }
private: 
 	HeapOnly() {}
 
     // C++98
     // 1.只声明,不实现。因为实现可能会很麻烦，而你本身不需要
     // 2.声明成私有
     HeapOnly(const HeapOnly&)；

     // or

     // C++11 
     HeapOnly(const HeapOnly&) = delete;
};

```

### 2请设计一个类，只能在栈上创建对象

```cpp
class StackOnly 
{ 
public: 
     static StackOnly CreateObject() 
     { 
     	return StackOnly();           //临时对象拷贝构造 返回
     }
private:
 	StackOnly() {}                     //不能私有拷贝构造
};

int main(){
    
    StackOnly s = StackOnly::CreateObject();
    
    return 0;
}

```

![image-20250731232548588](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250731232548588.png)

### 3请设计一个类，不能被拷贝

```c++
class CopyBan
{
 // ...
 
private:
     CopyBan(const CopyBan&);
     CopyBan& operator=(const CopyBan&);
 //...
};
```

```cpp
class CopyBan
{
     // ...
     CopyBan(const CopyBan&)=delete;
     CopyBan& operator=(const CopyBan&)=delete;
     //...
};

```



### 4请设计一个类，不能被继承

```c++
// C++98中构造函数私有化，派生类中调不到基类的构造函数。则无法继承
class NonInherit
{
public:
     static NonInherit GetInstance()
     {
     	return NonInherit();
     }
private:
     NonInherit()
     {}
    
    
};
```

### 5请设计一个类，只能创建一个对象(单例模式)

```c++
//懒汉模式

//类的名称就是随着你的场景给定
class MemoryPool{

public:
	static MemoryPool* GetInstance(){
		
        //双检查
        if(_mptr == nullptr)
        {
            //_mtx.lock();
            unique_lock<mutex>lock(_mtx);
            if(_mptr == nullptr)
            {
                _mptr = new MemoryPool;
            }
            //_mtx.unlock();
        }
        
        return _mptr;
	}
	
    MemoryPool(const MemoryPool& m) = delete;

private:
	MemoryPool()
	{}
	
	static MemoryPool* _mptr// 单例对象指针
    static mutex _mtx; //互斥锁
    // 防拷贝
 	MemoryPool(MemoryPool const&);
 	MemoryPool& operator=(MemoryPool const&);
 	
 	

}

```

```cpp
//饿汉模式

class Singleton
 {
 public:
     static Singleton* GetInstance()
     {
     	return &m_instance;
     }
 
 private:
 // 构造函数私有
 	Singleton(){};
 
 // C++98 防拷贝
     Singleton(Singleton const&); 
     Singleton& operator=(Singleton const&); 
 };
 
 Singleton Singleton::m_instance; // 在程序入口之前就完成单例对象的初始化


```

