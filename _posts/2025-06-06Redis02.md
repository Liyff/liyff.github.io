# C++54期Redis

## Day01

### 一、Redis数据库

#### 1、关系型数据库与非关系型数据库

MySQL：数据关系型数据库，使用的是表结构。

Redis：非关系型数据库，使用的是key-value

#### 2、非关系型数据库的分类

基于键值对 key-value类型：**Redis**，memcached
列存储数据库 Column-oriented Graph：HBase
图形数据库 Graphs based：Neo4j
文档型数据库： MongoDB
MongoDB是一个基于分布式文件存储的数据库，主要用来处理大量的文档。

#### 3、Redis的概念

远程字典服务器，使用C语言进行编写的，**高性能**的数据结构存储系统，它可以用作**数据库**、**缓存**和**消息中间件**。 它基于**内存**运行并支持**持久化**的NoSQL数据库，是当前最热门的NoSQL数据库之一。

redis中文官网：http://www.redis.cn/（https://redis.com.cn）
redis英文官网：https://redis.io/

#### 4、三大特点

- 支持**持久化**功能，也就是将数据从内存保存到磁盘中。
- 支持**丰富的数据类型**，包括：string、set、sort set、list、hash
- 支持数据的备份，也就是主从复制。

#### 5、优点

- 读写速率比较高，读的速率11w次/s  写的速率8.1w次/s
- 支持丰富的数据类型
- 原子性
- 丰富的特性，例如：发布订阅，key过期

### 二、redis五大数据类型与命令（==重要==）

![image-20240412150210121](C++54期Redis.assets/image-20240412150210121.png)

https://github.com/sewenew/redis-plus-plus

#### 0、常规命令

```redis
#数据库的切换 db是数据库的编号
select [db] 

#清空当前数据库
flushdb

#清空所有数据库
flushall

#删除key值
del key

#查看当前数据库key值的数量
dbsize

#查看当前数据库有哪些key值
keys  *

#设置某个key的过期时间
expire key  seconds   #expire k1 20    #设置k1的存活时间是20s

#查看key的剩余时间  -1代表永不过期   -2表示已经过期
ttl key

#查看key的类型
type key
```

#### 1、string数据类型

是二进制安全的，可以存放任意类型的数据。

```redis
#设置与获取
set k1 value1
get k1

mset k2 value2 k3 value3 k4 value4...
mget k1 k2 k3 ....

#获取子串
getrange key start end    #如果想找到最后一个可以使用-1
例如：getrange k1 0 4   
setrange key offset  value  

#incr/incyby  增加的key的value必须是数值类型
INCR/INCRBY key [num]  对value值加1/加num，value必须是数字
```

#### 2、list数据类型

双向链表

```redis
#添加元素有左右之分
lpush/rpush key value1 value2 value3 ....

#删除头或者尾
lpop/rpop key

#遍历
lrange key start end

#支持下标操作的
#可以使用下标进行获取lindex
lindex  key  [idx]

#可以使用下标进行设置lset
lset key [idx] newValue
```

#### 3、set数据类型

集合，底层使用的是哈希表，也就表明set中的元素是没有顺序的。

```redis
#添加元素的命令
sadd key value1 value2 value3....

#遍历
smembers key

#在集合中随机选出num个数
SRANDMEMBER key num 

#移除并返回集合中的一个/num个随机元素
SPOP key  [num] 
```

#### 4、sort set数据类型

可以为每个key设置double类型的分数进行排序

```redis
#添加元素
zadd key score1 value1  score2 value2 ....

#遍历元素
zrange key  start end [withscores]
```

#### 5、hash数据类型

字典，Key-value模式不变，但value是一个键值对，等价于map<key, map<key1, value>>

```Redis
#添加元素
hset key field value

#获取元素
hget key field 

#设置与获取多个
hmset/hmget
```



### 三、配置文件

#### 1、位置

```redis
/etc/redis路径下面，有一个6379.conf文件
```

#### 2、关闭redis服务器的方式

- 可以使用kill -9杀死进程id
- 可以进入到客户端使用shutdown命令

#### 3、启动redis服务器的方法（==重要==）

```redis
sudo redis-server 配置文件的路径
```



### 四、Redis的持久化(==重要==)

#### 1、概念

将数据从内存保存到磁盘中。

#### 2、分类

RDB：将当前数据保存到硬盘（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），默认的持久化方式。

AOF：将每次执行的写命令保存到硬盘（原理是将Reids的操作日志以追加的方式写入文件），主流的持久化方式。

#### 3、RDB持久化

##### 3.1、概念

指定的时间间隔能对你的数据进行快照存储。指定的==时间间隔==内，执行==指定次数的写操作==，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。（/var/lib/redis/6379）

##### 3.2、触发快照的方式

- 执行shutdown命令，会触发快照
- 执行flushall命令，会触发快照
- 手动执行save或者bgsave命令，会触发快照
- 在指定的时间间隔内，执行指定次数的写操作（自动触发）（两个条件要都成立）

```redis
save 30 2 #含义是，在30s以内执行2次以上的写操作，就会自动触发快照。
09:53:45的时候，执行一次save命令，然后快速执行两次写操作，当时间达到了09:54:00的时候。dump.rdb文件的最后更新时间没有变化，但是当时间来到09:54:15以后，时间差就达到了30，那么就会自动触发快照，也就是自动执行了save操作，dump.rdb文件的时间就被更新了。
```

#### 3.3、优缺点

##### 优点

- 适合大规模数据的恢复，恢复速率是比较快的
- 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。
- 使用的是二进制进行存储

##### 缺点

- 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。
- 备份时占用内存，因为Redis 在备份时会独立创建一个fork子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。

#### 4、AOF持久化

##### 4.1、概念

执行过的==写指令==记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单。

##### 4.2、重写

```redis
set k1 100
set k2 200
set k3 hello
set k1 400
incy k1
//...100
//104条代码

set k1 500
set k2 200
set k3 hello
```

##### 4.3、触发重写的方式

BGREWRITEAOF

```redis
Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

##### 4.4、优缺点

##### 优点

- 对数据的完整性与一致性的比较高

- 数据的丢失比较小（相对RDB而言）

##### 缺点

- 不适合大规模数据的恢复，因为恢复的速率比较慢，需要将所有的写命令重新执行一次
- 因为使用的是文件追加的模式，所以文件的体积会比较大

#### 5、总结

- 两种持久化的方式都可以同时存在，如果对数据的恢复速率比较快，可以选择rdb持久化；如果对数据的完整性与一致性要求比较高（更加精确），可以选择aof持久化
- 单独使用aof持久化的方式，也是可以启动服务器的
- 如果aof持久化是唯一的方式，那么如果该文件损坏了，就不能启动服务器
- 如果aof文件损坏了，可以使用修复命令进行修复文件，redis-check-aof 

![image-20240413111002189](C++54期Redis.assets/image-20240413111002189.png)



### 五、Redis的事务

#### 1、概念

一组命令的集合。

#### 2、三个阶段

- 开始事务
- 命令入队
- 执行事务

#### 3、事务的命令

```redis
#标记一个事务块的开始。
multi

#执行所有事务块内的命令。
exec

#取消事务，放弃执行事务块内的所有命令
DISCARD
```

总结：

==redis的事务是没有原子性的，也就是在事务中每一条命令执行成功与否，对其他命令没有影响==

![image-20240413112615730](C++54期Redis.assets/image-20240413112615730.png)



![image-20240413112716695](C++54期Redis.assets/image-20240413112716695.png)



悲观锁：每次拿数据的时候，认为其他线程会对共享资源进行修改，所以每次都要加锁（Linux中的互斥锁）

乐观锁：每次拿数据的时候，认为其他线程会对共享资源不会进行修改，所以每次都不需要要加锁（==可以使用两种机制，版本号机制与CAS机制==）



### 六、主从复制

#### 1、概念

将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为**主节点**(master)，后者称为**从节点**(slave)；数据的复制是==**单向**==的，只能由主节点到从节点。

#### 2、配置步骤

- 在/etc/redis下面，将6379.conf文件拷贝两份，分别叫做6380.conf与6381.conf
- 将6380.conf与6381.conf文件下面的如下配置进行修改

```C++
port 6380     port 6381
pidfile "/var/run/redis_6380.pid"  pidfile "/var/run/redis_6381.pid"
logfile "/var/log/redis_6380.log"  logfile "/var/log/redis_6381.log"
dbfilename "dump6380.rdb" dbfilename "dump6381.rdb"
appendfilename "appendonly6380.aof"  appendfilename "appendonly6381.aof"
```

- 启动上述三个配置文件

```redis
sudo redis-server /etc/redis/6379.conf
sudo redis-server /etc/redis/6380.conf
sudo redis-server /etc/redis/6381.conf
```

- 进入到对应服务器的客户端

```redis
redis-cli -p 6379
redis-cli -p 6380
redis-cli -p 6381
```

- 接下来查看主从复制的信息info replication，每个机器都是属于主机
- 再配置主从复制，可以在从机上执行以下命令

```redis
SLAVEOF 127.0.0.1 6379
```

就可以看到主机上能感知从机已经连上来了，并且看到从机的ip与端口号以及状态。同时从机上也可以看到主机的ip与port，以及状态信息，并且主机上的数据会复制到从机来。

现象

1、当从机挂掉之后，主机不会记录从机的信息，也就是挂掉的从机与主机之间已经没有关系了，当从机再启动，是以主机的身份启动

2、如果主机断开，那么两个从机会感知到主机的下线，然后默默地等待主机的上线（同时会记住主机的ip、port、状态信息），当主机上线之后，立马就可以感知到主机的状态为up

3、如果主机断开之后，一直不上线，那么两个从机就一直是从机的身份，所以是有缺陷的（如果有新的写操作上来，就不能进行写）



### 七、哨兵模式

#### 1、概念

执行留言协议（造谣）与投票协议（少数服从多数）

#### 2、配置

- 在/etc/redis下面建一个文件sentinel.conf，然后在其中添加如下命令

```redis
#哨兵     监视    主机名      主机ip       端口 票数                                       sentinel monitor master6379 127.0.0.1 6379 1
```

- 启动配置文件sentinel.conf

```redis
sudo redis-sentinel /etc/redis/sentinel.conf
```

- 接下来关闭主机，然后哨兵就会执行两个协议，最终将其中的一票投递给6380或者6381，谁得到这一票，谁就是新的主机。

总结：哨兵模式可以解决传统主从复制关系中，主机挂掉之后，从机不能成为新的主机的问题。

### 八、三个面试常见概念（==重要==）

#### 1、缓存雪崩

概念：**大量热点数据在同一时间失效**，导致本来可以在缓存中查找到的数据，必须要到底层数据库下面进行查找，会对底层数据库的压力比较大。

解决方案：1、分散数据的失效时间   2、可以延长热点数据的失效时间或者让数据不失效

![image-20240413155027546](C++54期Redis.assets/image-20240413155027546.png)

#### 2、缓存击穿

问题：==某个热点数据失效了==，导致本来可以在缓存中访问到的，现在只能到底层数据库中进行查找，会增加底层数据库的压力

解决方法：1、延长热点数据的失效时间或者让数据永远不失效   2、让每个客户端互斥访问数据库（加锁）

![image-20240413160022892](C++54期Redis.assets/image-20240413160022892.png)

#### 3、缓存穿透

问题：要访问的数据本身是不存在，在缓存中找不到，就会到底层数据库中进行查找，也会增加对底层数据库的访问压力。

解决方案：1、可以设置键值对，存放在缓存中，value为空，<key1,NULL>

![image-20240413160406679](C++54期Redis.assets/image-20240413160406679.png)