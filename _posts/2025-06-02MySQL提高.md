# MySQL提高

### 事务transcation

ACID

strart transcation;     commit;    rollback;

#### 并发问题：脏读，脏写，不可重读，幻读



#### 设置隔离级别

```
SELECT @@transaction_isolation; #查看隔离级别
```

**set  session  transaction  isolation  level** READ UNCOMMITTED;

#### 隔离级别：读未提交，读已提交，可重复读(repeatable read)RR，串行化

```
InnoDB 存储引擎通过多版本并发控制（MVCC）来解决
幻读问题。MVCC 是一种并发控制机制，允许事务在读取数据时看到一个一致性的快照，
```



### 索引

B树和B+树区别：

```
B+树所有的数据域都存储在叶子节点中，而非叶子节点只存储索引信息，
在B树，每个节点中既存储索引信息，又存储数据域
B+树由于非叶子节点的只存储索引，所以相较B树，一页能够保存的非叶子节点会更多
```

create table test (id int **primary key**, col1 int **unique key**, col3 int, col4  varchar(30));

每增加一个索引就增加一个B+树

#### 常规索引

```
CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    ...
    INDEX index_name (column1, column2)
);
# 建好表以后再新增索引
CREATE INDEX index_name ON table_name (column1, column2);
ALTER TABLE table_name ADD INDEX index_name (column1, column2);
# 删除索引
DROP INDEX index_name ON table_name;
```

### 列的数量

#### 单列索引

- 以单字段内容作为索引的排序查找的依据

#### 组合索引（重点）

- 组合索引的多个字段是有序的，遵循左对齐的原则，
- 筛选的条件也要遵循从左向右的原则，如果中断，那么，断点后面的条件就没有办法利用索引了

```
create table test (id int primary key, col1 int,col2 varchar(30), col3 int, col4
varchar(30), index myindex(col3,col2,col1));
# 在访问索引时，先定位col3，再定位col2，最后定位col1
```

### 存储性质

**聚簇索引**是一种特殊类型的索引，它与表的物理顺序一致存储在一起（表的主键索引就是一种聚簇索引）B+树

**非聚簇索引**（或称为次要索引）将索引存储在一个地方，而实际数据存储在另一个地方（组合索引）



### MySQL支持的存储引擎

```
Engine: InnoDB
Support: DEFAULT
Comment: Supports transactions, row-level locking, and foreign keys
```

- 事务        行级锁       外键

#### 外建

一个表的列（参照表）引用了另一个表的主键列（被参照表）的值作为外键，参照表的外键列
中的值只能从被参照表的关联列中已存在的值当中选取

```
create table hero (hid int primary key, name varchar(30));
insert into hero values(1,'刘备'),(3,'张飞'),(5,'赵云');

create table weapon (wid int primary key, wname varchar(30), hid int, constraint
foreign key (hid) references hero(hid));

mysql> insert into weapon values (1,'丈八蛇矛',3);
Query OK, 1 row affected (0.00 sec)

mysql> insert into weapon values (2,'青龙偃月刀',2);
ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint

mysql> delete from hero where hid = 3;
ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key

```



#### InnoDB支持行级锁

- 上读锁，在上读锁不阻塞，写入其他行不阻塞，写入同一行被阻塞 
- 上写锁（互斥锁），再上写锁/读锁都阻塞，写入其他行不阻塞，写入同一行被阻塞

```
1>begin; # 开启事务
1>select * from test1 where id = 1 lock in share mode; # 上读锁
2>begin; # 开启事务
2>select * from test1 where id = 1 lock in share mode; # 再上读锁不阻塞
2>insert into test1 values (2,'123','456'); # 插入不阻塞
2>update test1 set col1 = '234' where id = 2; # 写入另一行也不阻塞
2>update test1 set col1 = '234' where id = 1; # 写入同一行被阻塞了


1>begin; # 开启事务
1>select * from test1 where id = 1 for update; #上写锁  类似于互斥锁
2>begin; # 开启事务
2>select * from test1 where id = 1 for update; # 再上写锁阻塞
2>select * from test1 where id = 1 lock in share mode; # 上读锁也阻塞
2>update test1 set col2 = 'def' where id = 1; #写入也阻塞
2>select * from test1 where id = 2 for update;# 其他行没有任何问题
```

读写不是同一行可以成功



##### 在InnoDB引擎的RR级别  select * from   MVCC快照可以解决幻读问题

当事务中第一次 select * from  生成一个快照,随后每一次只读快照表，不读当前最新表

select * from for update  当前锁   -> 间隙锁

**间隙锁**（Gap Lock）是MySQL InnoDB存储引擎的一种特殊类型的锁，用于锁定索引范围而不是
特定的行



#### InnoDB的On-disk结构

```
./undo_002
# undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。
# redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复；
```





### MyISAM的特性

```
# 创建 MyISAM 表格
CREATE TABLE my_table (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50),
    age INT
) ENGINE=MyISAM;
1>LOCK TABLES my_table WRITE; # 1上写锁
2>LOCK TABLES my_table WRITE; # 2上写锁阻塞

# LOCK TABLES my_table READ; # 上读锁
# 在事务中执行对表格的操作
1>INSERT INTO my_table (name, age) VALUES ('John', 30);
1>INSERT INTO my_table (name, age) VALUES ('Alice', 25);
# 释放表锁
1>UNLOCK TABLES;
2>LOCK TABLES my_table READ;
2>SELECT * FROM my_table; #OK
2>INSERT INTO my_table (name, age) VALUES ('Bob', 20); #报错
```

```
MyISAM存储引擎中会修改哪些磁盘文件
./improve/my_table.MYI #索引文件
./improve/my_table.MYD #数据文件
```

###  

### MEMORY存储引擎的特性

```
create table test2 (id int primary key, col1 varchar(20), col2 int) engine =
memory;
insert into test2 values (1,'abc',1); # 插入表中的内容在断电以后会消失

```



### 执行计划 explain

```
explain select * from large_table where id = 10000\G

*************************** 1. row ***************************
id: 1
select_type: SIMPLE
table: large_table
partitions: NULL
type: const
possible_keys: PRIMARY
key: PRIMARY
key_len: 4
ref: const
rows: 1
filtered: 100.00
Extra: NULL
1 row in set, 1 warning (0.00 sec)

```

#### 索引失效

```
# 如果表达式对索引列做了运算，可能会导致索引失效
mysql> explain select * from large_table where id + 10000 = 20000\G
#根据col2索引去查找
explain select * from test3 where col2 = 6 and col1 = 5\G

# 使用了<>导致了主键索引失效
mysql> explain select * from test3 where id <> 'aab'\G
#使用or也导致索引失效了
mysql> explain select * from test3 where id < 'aab' or id > 'add'\G
#使用union效果更好
explain select * from test3 where id < 'aab' union select * from test3 where id
> 'add'\G
# 尽量避免出现数值到字符串的自动转换，这会导致索引失效
explain select * from test3 where id = 123\G

```

