---
layout:     post   				    # 使用的布局（不需要改）
title:      数据结构>栈和队列 				# 标题 
subtitle:   栈, 队列 #副标题
date:       2025-03-20 				# 时间
author:     LYF 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签

   - 数据结构
     - 栈
     - 队列
---

# 介绍

![image-20250331220238254](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250331220238254.png)

栈：一种特殊的线性表，只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除 操作的一端称为栈顶，另一端称为栈底。

队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先 进先出FIFO(First In First Out) 入队列：进行插入操作的一端称为队尾 出队列：进行删除操作的一 端称为队头。

### 声明

```
//栈
//静态定长栈
#define N 10
typedef int STDataType;

typedef struct Stack
{
 	STDataType _a[N];
 	int _t
}Stack;
//动态增长栈
typedef struct Stack
{
	STDataType* _a;
 	int _top;      // 栈顶
	int _capacity;  // 容量 
}Stack;

//队列
typedef int QDataType;
typedef struct QueueNode
{
	QDataType data;
	struct QueueNode* next;
}QueueNode;

typedef struct Queue
{
	QueueNode *head; //front
	QueueNode *tail; //rear
}Queue;

```





### OJ

1.有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

**输入：**s = "()"

**输出：**true

**示例 2：**

**输入：**s = "()[]{}"

**输出：**true

**示例 3：**

**输入：**s = "(]"

**输出：**false

**示例 4：**

**输入：**s = "([])"

**输出：**true

**算法思路：**利用栈的后进先出特性，进行括号的匹配，当遍历到左括号就进行入栈，遍历到右括号就让其与栈顶元素进行比较，满足就让栈顶元素出栈，继续向下遍历字符，如果其与栈顶元素不相等直接返回false，注意：跳出循环有两种情况，一种时字符遍历完，另一种时匹配失败。

```
bool isValid(char* s) {

    Stack st;
    StackInit(&st);
    bool ret;

    while(*s)
    {
        
        if(*s == '('||*s == '{'||*s == '[')
        {
            StackPush(&st,*s);
        }
        else
        {   //如果栈内已经空
            if(StackEmpty(&st))   
            {
                ret=false;
                break;
                //return false;
            }    
                
            //获取栈顶元素
            char top = StackTop(&st);
            if(*s == ')' && top != '(')
            {
                ret=false;
                break;
                //return false;
            }  
            if(*s == '}' && top != '{')
            {
                ret=false;
                break;
                //return false;
            }  
            if(*s == ']' && top != '[')
            {
                ret=false;
                break;
                //return false;
            }  
            
            StackPop(&st);    
            
        }

        
        s++;
    }
    //字符串遍历完
    if(*s=='\0')
    {
        ret = StackEmpty(&st);
    }

    StackDestory(&st);
    return ret;
    
}
```



2.用队列实现栈

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。

**注意：**

- 你只能使用队列的标准操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

**示例：**

```
输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]
```



3.用栈实现队列

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**

- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

**示例 1：**

```
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]
```