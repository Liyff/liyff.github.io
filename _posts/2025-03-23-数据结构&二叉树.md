---
layout:     post   				    # 使用的布局（不需要改）
title:      数据结构>二叉树 				# 标题 
subtitle:   栈, 队列 #副标题
date:       2025-03-20 				# 时间
author:     LYF 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签

   - 数据结构
     - 二叉树 
     
---

# 介绍

### 树

--》二叉树

--》--》完全二叉树

--》--》--》满二叉树

![image-20250408215926150](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250408215926150.png)



完全二叉树高度：h = logN + 1

满二叉树高度：h = log(N+1)



![image-20250408221700245](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250408221700245.png)



### 堆

![image-20250408222246626](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250408222246626.png)

### OJ

1.最小的k个数

设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。

**示例：**

```
输入： arr = [1,3,5,7,2,4,6,8], k = 4
输出： [1,2,3,4]
```

**算法思路：**通过堆的特性，大根堆中父亲结点都是大于左右孩子结点，那么先选取数组中前K个元素建立拥有K个结点的大根堆，然后依次遍历剩下（N-K）个元素，通过与大根堆顶元素比较进行向下调整，如果该元素大于堆顶元素肯定不是要求K个数中之一（舍弃），如果该元素小于堆顶元素，把该元素赋值给堆顶元素，然后进行向下调整为大根堆，依次往下遍历数组，直到最后，那么此时堆中的K个结点即为所求最小K个数。

```
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 //堆排序 要实现递增建大根堆，实现递减建小根堆

//TopK 建拥有K个元素的堆， 找最小k个建大根堆，找最大k个建小根堆
int* smallestK(int* arr, int arrSize, int k, int* returnSize) {
    
    //
    *returnSize = k;

    //开辟k个大小的数组
    int* retArr = (int*)malloc(sizeof(int)*k); 

    if(k<1)
        return retArr;
    
    for(int i = 0;i<k;i++)
    {
        retArr[i] = arr[i];
    }

    void AdjustDown(int* a,int n,int root)
    {
        int parent = root;
        int child = parent*2+1;
        
        while(child<n)
        {
            //找出最大的孩子
            if(child+1<n && a[child]<a[child+1])
            {
                child++;
            }

            if(a[child]>a[parent])
            {   //交换父子，大的为父
                int tmp =  a[child];
                a[child] = a[parent];
                a[parent] = tmp;

                //继续向下调整
                parent = child;
                child = parent*2+1;
            }
            else
            {
                break;
            }
        }

    }
    //1.retArr建大根堆        根也要调整i>=0;
    //初始从第一个非叶结点开始向下调整，左右孩子小于父亲结点
    for(int i = (k-1-1)/2;i>=0;i--)
    {
        AdjustDown(retArr,k,i);
    }
    
    //2.遍历数组arr的元素与K堆顶进行比较(retArr[0]) 
    //比堆顶小的元素做向下调整
    for(int j = k;j<arrSize;j++)
    {
        if(arr[j]<retArr[0])
        {
            retArr[0] = arr[j];
            AdjustDown(retArr,k,0);
        }
    }

    return retArr;

}
```

