# C++类型转换

![image-20250802221304053](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250802221304053.png)

### static_cast 

static_cast用于非多态类型的转换（静态转换），编译器隐式执行的任何类型转换都可用static_cast，但它
不能用于两个不相关的类型进行转换

（相近类型）

```c++
double d = static_cast<double>(b);
```



###  reinterpret_cast

reinterpret_cast操作符通常为操作数的位模式提供较低层次的重新解释，用于将一种类型转换为另一种不
同的类型

（不相近类型）

```c++
int a = 3;
int * p = reinterpret_cast<int*>(&a);
```



### const_cast

const_cast最常用的用途就是删除变量的const属性，方便赋值

```cpp
void Test ()
 {
     const int a = 2;			//原因：const常量存放在寄存器中
     int* p = const_cast< int*>(&a );  
     *p = 3;			
     cout<<a <<endl;  //控制台打印从寄存器取还是2 但是内存中已经改为3
 }

```

```cpp
void Test ()
 {
     volatile const int a = 2;	//volatileu关键字：禁止编译器优化，每次到内存中取值
     int* p = const_cast< int*>(&a );  
     *p = 3;			
     cout<<a <<endl;  //控制台打印是3，内存也是3
 }
```



### dynamic_cast

dynamic_cast用于将一个父类对象的指针/引用转换为子类对象的指针或引用(动态转换）

（向下转型）

```c++
class A
 {
public :
     virtual void f(){}
 };
class B : public A
 {};
void fun (A* pa)
 {
     // dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回
     B* pb1 = static_cast<B*>(pa);
     B* pb2 = dynamic_cast<B*>(pa);

     cout<<"pb1:" <<pb1<< endl;
     cout<<"pb2:" <<pb2<< endl;
 }
int main ()
 {
     A a;
     B b;
     fun(&a);
     fun(&b);
     return 0;
 }

```

###  explicit

explicit关键字阻止经过转换构造函数进行的隐式转换的发生

```c++
class A
 {
public :
explicit A (int a)
     {
     	cout<<"A(int a)" <<endl;
     }
     A(const A& a)
     {
     	cout<<"A(const A& a)" <<endl;
     }
private :
 	int _a ;
 };
int main ()
 {
     A a1 (1);
     A a2 = 1;// 编译器解析为，隐式转换-> A tmp(1); A a2(tmp);

 }
```

