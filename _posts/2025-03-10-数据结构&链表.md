---
layout:     post   				    # 使用的布局（不需要改）
title:      数据结构>链表 				# 标题 
subtitle:   Hello World, Hello Blog #副标题
date:       2025-03-10 				# 时间
author:     LYF 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签

   - 数据结构
     - 链表
---



# 介绍

链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表 中的指针链接次序实现的 。

链表的出现是为了弥补顺序表的不足而出现的，链表的特点就像一条大金链子，增删较方便。

### 声明

```
//SingleList单链表
typedef int SLDataType;

typedef struct SLinkedNode
{
	SLDataType data;
	struct SLinkedNode* next;

}SLNode;
```

### OJ

1.反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

**算法思路：**利用三个指针进行指向的修改，curNext记录结点cur下一个结点，prev用来记录结点cur上一个结点，修改当前结点cur指向prev，修改完cur指向后，prev指向当前cur结点，之后cur指向下一个结点，curNext指向下一个结点，依次遍历链表。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* reverseList(struct ListNode* head) {
    //0个结点或1个结点
    if(head==NULL||head->next==NULL)
        return head;
    //多个结点

    struct ListNode* prev = NULL,*cur = head,*curNext = cur->next;
    
    while(cur)
    {
        //修改当前结点指向
        cur->next = prev;
        //迭代链表
        prev = cur;
        cur = curNext;
        if(curNext)
            curNext = curNext->next;
        
    }
    
    return prev;

}

法二：
struct ListNode* reverseList(struct ListNode* head){

    // if(head==NULL||head->next==NULL)
    //     return head;
    //头插
    struct ListNode* newhead = NULL,*cur = head;
    while(cur)
    {
        struct ListNode* curNext = cur->next;
        
        cur->next = newhead;
        newhead=cur;
        cur=curNext;
        
    }
    return newhead;

}
```

2.删除链表中等于给定值val值的所有结点

3.链表的中间结点

4.输出链表中倒数第k个结点

实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

**注意：**本题相对原题稍作改动

**示例：**

```
输入： 1->2->3->4->5 和 k = 2
输出： 4
```

**说明：**

给定的 *k* 保证是有效的。

```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
 typedef struct ListNode Node;
int kthToLast(struct ListNode* head, int k) {
    
    Node* slow=head,*fast = head;
    //fast先走k位
    while(k--)
    {
        if(fast)
        {
            fast=fast->next;
        }
        
    }

    while(fast)
    {
        slow = slow->next;
        fast = fast->next;
    }
    return slow->val;

}
```



