# 文件

不带缓冲的文件IO

![image-20250616172305374](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250616172305374.png)

## open(path,flags,mode_t)

- **open(path,flags)**文件存在就不用设定权限
- 返回文件描述符int
- flags [O_RDONLY  O_WRONLY  O_RDWR     | O_CREAT  O_TRUNC  O_APPEND]  

man 2 open

```
int fd = open(path,"O_RDWR|O_CREAT|O_TRUNC");
```

## read(fd,buf,count)

- 返回值读的字节数sszie_t   >0  =0    -1

- count应当是申请内存的大小

- read前清空buf

  ```
  ssize_t ret = read(fd,buf,sizeof(buf));
  ```

  

![image-20250616194429820](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250616194429820.png)

## write(fd,buf,count)

- 如果是文本文件字节数count就用strlen(),二进制就用sizeof()
- 怎么读就怎么写，读多少写多少

```
write(fd,buf,ret);//ret代表读多少写多少字节
```

## 实现拷贝

```
./copyFile.c file1  file2

```



## 性能问题

使用文件流fopen fread fwrite 					先把文件拷贝到用户态文件缓冲，然后一起拷贝到内核态

使用不带缓冲的文件IO  open read write   尽量让buf大一点可以减少用户态到内核态切换次数

![image-20250616201145673](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250616201145673.png)

## fruncate(fd,length)

文件截断

- 大到小截断后面，小到大后面补0

- 会产生文件空洞

```
int ret = fruncate(fd,40960);
```

## 内存映射mmap

![image-20250616203425113](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250616203425113.png)

### mmap(NULL,length,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0)

- 返回值void*
- 文件大小是固定的 ftruncate()
- 只能是磁盘文件
- 建立映射之前先open()
- **munmap关闭映射**

```
char* p = (char*)mmap(NULL,5,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0)
ERROR_CHECK(p,MAP_FAILED,"mmap");//注意坑
for(int i = 0;i<5;i++){printf("%c",p[i]);}
munmap(p,5)
```

## lseek(fd,0,SEEK_SET)

ptr偏移文件开头

![image-20250616205332193](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250616205332193.png)

**文件流底层使用了文件对象**



fileno(fp);//返回文件流文件描述符

![image-20250616210906130](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250616210906130.png)