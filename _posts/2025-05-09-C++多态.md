# 多态

virtual关键字

- 可以修饰成员函数，为了完成虚函数重写，满足多态条件之一。

- 可以在菱形继承中，去完成虚继承，解决数据冗余和二义性。

**多态两个条件：**

- 虚函数的重写
- 父类对象的指针或者引用去调用虚函数

**满足多态**：跟调用对象的类型无关，指向哪个对象就调用它的虚函数

**不满足多态**：对类型有关，调用的类型是谁，就是谁的成员

## 虚函数重写

参数，函数名，返回值都相同，

原理：虚函数地址存放到对象的虚函数表（虚表）中，多态指向谁调用本质是运行到对象虚表找要调用的虚函数。

**协变**：基类与派生类虚函数返回值类型是不同类型对象

```
class A{};
 class B : public A {};
 
class Person {
 public:
    virtual A* f() {return new A;}
 };
 
class Student : public Person {
 public:
    virtual B* f() {return new B;}
 };
```

**析构函数**：函数名不同



## override和final

override修饰虚函数重写，检查是否重写

final修饰的虚函数不能重写

- 重载：两个函数在同一作用域，函数名相同参数不同

- 重写：两个虚函数分别在基类和派生类作用域，函数名参数返回值都相同，（协变/析构除外）

- 重定义：两个分别在基类和派生类的同名函数（非virtual虚函数）



## 抽象类

包含纯虚函数的类，抽象类不能实例化出对象

```
 class Car
 {
 public:
 	//纯虚函数
    virtual void Drive() = 0;
 private:
 	int _circle;
 };

sizeof(Car)  32位下占8个字节  因为有虚表指针vftptr
 
 //子类重写父类纯虚函数后才能实例化
 class Benz :public Car
 {
 public:
    virtual void Drive()
    {
        cout << "Benz-舒适" << endl;
    }
 };
```

### 多态原理

![image-20250617215428325](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250617215428325.png)

1.虚函数存在哪？  代码段

2.虚函数表存在哪？代码段（常量区）

一个类的不同对象共享该类的虚表

#### 动态绑定和静态绑定

动态绑定： 动态的多态   运行时到虚表中找虚函数地址

静态绑定： 静态的多态   编译时确定函数地址

### 单继承和多继承的虚函数表

单继承

![image-20250617230338074](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250617230338074.png)

多继承

![image-20250617230309854](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250617230309854.png)
