# C++11

容器支持花括号列表初始化，本质是增加一个initializer_list的构造函数

initializer_list可以接收花括号的列表

### 类型推导

```
string s;

decltype(s) str;
```

### find和override

### C++98容器

string/vector/list/deque/map/set/bitset + stack/queue/priority_queue

### C++11新容器

array(定长数组)/forword_list(单链表，只能头插头删)

unordered_map/unordered_set 

新增加默认函数

```
// 禁止编译器生成默认的拷贝构造函数以及赋值运算符重载
 A(const A&) = delete;
 A& operator(const A&) = delete;
```

### 右值引用和移动语义（重点）

```
// 普通类型引用只能引用左值，不能引用右值
 int a = 10;
 int& ra1 = a; // ra为a的别名
 //int& ra2 = 10; // 编译失败，因为10是右值
 
 const int& ra3 = 10;//加上const可以引用右值起别名
 const int& ra4 = a;
```

```
// 10纯右值，本来只是一个符号，没有具体的空间，
 // 右值引用变量r1在定义过程中，编译器产生了一个临时变量，r1实际引用的是临时变量
 int&& r1 = 10;
 r1 = 100;
 int a = 10;
 int&& r2 = a; // 编译失败：右值引用不能引用左值
 int&& r3 = move(a);//加上move就可以引用左值起别名
```

纯右值：常量，表达式/函数返回值

将亡值：自定义临时对象

```


String(char* str = "")
{
     if(str == nullptr){
        str = "";
     }
     _str = new char[strlen(str) + 1];
     strcpy(_str,str);
}
//左值引用
String(const String& s)
	:_str(new char[strlen(s._str)+1])
{
	//深拷贝
	strcpy(_str,s._str);
}

String(String&& s)
	:_str(nullptr)
{//右值-将亡值     移动拷贝-效率高
//传过来一个将亡值，反正你都要亡了
	swap(_str,s._str); //移动拷贝
}


```



右值引用做返回值

```
String& operator=(const String& s){
	if(this!=&str){
		char* tmp = new char[strlen(s._str)+1];
		strcpy(tmp,s._str);
		
		delete[] _str;
		_str = tmp;
	}
	return *this;
}
//传入参数 右值-将亡值
String& operator=(String&& s){
	swap(_str,s._str); //移动赋值
	return *this;
}

```

右值引用做参数

主要用在insert()/push_back()上

![image-20250716231219169](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250716231219169.png)

![image-20250716232943657](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250716232943657.png)

![image-20250716232834171](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250716232834171.png)

#### 完美转发

函数模板在向其他函数传递自身形参时，如果相应实参是左值，它就应该被转发为左值；如果相
应实参是右值，它就应该被转发为右值

```
void Fun(int &&x){cout << "rvalue ref" << endl;}
void Fun(const int &x){cout << "const lvalue ref" << endl;}
void Fun(const int &&x){cout << "const rvalue ref" << endl;}

template<typename T>
void PerfectForward(T &&t){
	Fun(std::forward<T>(t));//完美转发
}

int main()
{
     PerfectForward(10); // rvalue ref

     int a;
     PerfectForward(a); // lvalue ref
     PerfectForward(std::move(a)); // rvalue ref
     const int b = 8;
     PerfectForward(b); // const lvalue ref
     PerfectForward(std::move(b)); // const rvalue ref
     return 0;
}
```

### lambda表达式（匿名函数）

函数对象，又称为仿函数，即可以想函数一样使用的对象，就是在类中重载了operator()运算符的类对象

![image-20250718223912105](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250718223912105.png)



```

[ 捕捉列表 ] ( 参数 ) ->返回值类型{函数体}

[=]：表示值传递方式捕获所有父作用域中的变量(包括this)
[&]：表示引用传递捕捉所有父作用域中的变量(包括this)
int main()
{
     Goods gds[] = { { "苹果", 2.1 }, { "相交", 3 }, { "橙子", 2.2 }, {"菠萝", 1.5} };
     sort(gds, gds + sizeof(gds) / sizeof(gds[0]), [](const Goods& l, const Goods& r)->bool{
             return l._price < r._price;
     });
     return 0;
}
```

```
// 省略参数列表和返回值类型，返回值类型由编译器推导为int
 int a = 3, b = 4;
 [=]{return a + 3; }; 
 
 // 省略了返回值类型，无返回值类型
 auto fun1 = [&](int c){b = a + c; }; 
 fun1(10)
 cout<<a<<" "<<b<<endl;
 
 // 各部分都很完善的lambda函数
 auto fun2 = [=, &b](int c)->int{return b += a+ c; }; 
 cout<<fun2(10)<<endl;
 
 // 复制捕捉x
 int x = 10;
 auto add_x = [x](int a) mutable { x *= 2; return a + x; }; 
 cout << add_x(10) << endl; 
```

```
std::swap(a,b);//指定作用域
::swap(a,b)//全局作用域

int a = 1,b = 2;
//不捕捉
auto swap1 = [](int& x1,int& x2){
	int tmp = x1;
	x1 = x2;
	x2 = tmp;
};
swap1(a,b);

//捕捉  mutable可以取消其常量性
auto swap2 = [a,b]()mutable{
	int tmp = a;
	a = b;
	b = tmp;
};
swap2();//这里交换失败是因为 拷贝传值

//捕捉   
auto swap3 = [&a,&b](){
	int tmp = a;
	a = b;
	b = tmp;
	
}
swap3();
```

底层还是依靠仿函数来实现的，编译器生成一个全局的lambda_uuid类，仿函数operator()的参数和实现



### C++11支持线程库

线程函数的参数是以值拷贝的方式拷贝到线程栈空间中的

```
#include <iostream>
using namespace std;
#include <thread>
void ThreadFunc(int a)
{
 	cout << "Thread1" << a << endl;
}
class TF
{
public:
     void operator()()
     {
     	cout << "Thread3" << endl;
     }
};
int main()
{
     // 线程函数为函数指针
     thread t1(ThreadFunc, 10);

     // 线程函数为lambda表达式
     thread t2([]{cout << "Thread2" << endl; });

     // 线程函数为函数对象
     TF tf;
     thread t3(tf);
 
     t1.join();
     t2.join();
     t3.join();
 	cout << "Main thread!" << endl;
 	return 0;
}

```

####  原子性操作库(atomic)

对变量

```
#include <iostream>
using namespace std;
#include <thread>
#include <atomic>
atomic<long> sum = 0;

void fun(size_t num)
{
     for (size_t i = 0; i < num; ++i)
     sum ++; // 原子操作
}
int main()
{
     cout << "Before joining, sum = " << sum << std::endl;
     thread t1(fun, 1000000);
     thread t2(fun, 1000000);
     t1.join();
     t2.join();

     cout << "After joining, sum = " << sum << std::endl;
     return 0;
}

```

一个线程打印奇数，一个线程打印偶数，依次打印  （生产者消费者模型）

![image-20250719234200679](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250719234200679.png)
