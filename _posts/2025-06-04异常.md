---

---

# 异常

### 捕获和抛出

throw可以抛出任意类型的对象，直接跳到catch匹配的地方

```c++
#include <iostream>
using namespace std;

int div()
{
	int a, b;
	cin >> a >> b;
	if (b == 0) {
		throw invalid_argument("除0错误");
	}
	return a / b;
}

void f1() {
	int* p = new int;
	cout << div() << endl;
	delete p;	
}

int main() {

	try {
		f1();
	}
	catch (exception& e) {
		cout << e.what() << endl;
	}
	return 0;
}
```



```c
double Division(int a, int b)
{
     // 当b == 0时抛出异常
     if (b == 0)
     	throw "Division by zero condition!";    //抛出的是它的拷贝
     else
     	return ((double)a / (double)b);
}
void Func()
{
     int len, time;
     cin >> len >> time;
     cout << Division(len, time) << endl;
}

int main()
{
     try {
     	Func();
     }
     catch (const char* errmsg） {
     	cout << errmsg << endl;
     }
     catch(...){
     	cout<<"unkown exception"<<endl; 
     }
     return 0;
}

```

### 异常重新抛出

```c
double Division(int a, int b)
{
 // 当b == 0时抛出异常
     if (b == 0)
     {
     	throw "Division by zero condition!";
     }
     return (double)a / (double)b;
}
void Func()
{
     // 这里可以看到如果发生除0错误抛出异常，另外下面的array没有得到释放。
     // 所以这里捕获异常后并不处理异常，异常还是交给外面处理，这里捕获了再
     // 重新抛出去。
     int* array = new int[10];
     try {
     int len, time;
     cin >> len >> time;
     cout << Division(len, time) << endl;
 }
 catch (...)
 {
     cout << "delete []" << array << endl;
     delete[] array;
     throw;
 }
     // ...
     cout << "delete []" << array << endl;
     delete[] array;
}

int main()
{
     try
     {
     	Func();
     }
     catch (const char* errmsg)
     {
     	cout << errmsg << endl;
     }
     return 0;
}
```

### 异常规范

```cc
// 这里表示这个函数会抛出A/B/C/D中的某种类型的异常
void fun() throw(A，B，C，D);
// 这里表示这个函数只会抛出bad_alloc的异常
void* operator new (std::size_t size) throw (std::bad_alloc);
// 这里表示这个函数不会抛出异常
void* operator new (std::size_t size, void* ptr) throw();

```

### 异常安全

- 构造函数完成对象的构造和初始化，最好不要在构造函数中抛出异常，否则可能导致对象不完整或没有完全初始化
- 析构函数主要完成资源的清理，最好不要在析构函数内抛出异常，否则可能导致资源泄漏(内存泄漏、句柄未关闭等)