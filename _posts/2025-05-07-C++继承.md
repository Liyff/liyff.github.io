## 继承

```
class Person
{
protected:
		string _name;
		int _age;

};

class Student : public Person
{
protected:
		int _stuid;//学号
};
class Teacher : public Person
{
protected:
		int _jobid;//工号
};
```

继承访问方式取基类和派生类最小的访问方式

#### 子类和父类之间的赋值兼容规则

1.子类对象可以赋值给父类对象/指针/引用

```
Student st;
Person p;
p = st; //切片
Person* ptr = &st;  
Person& ref = st;
```



继承作用域

```
当父类和子类同时有同名成员时，子类成员隐藏了父类的成员（重定义）
指定作用域就可以调父类同名成员
```



```
class Person
 {
 public :
 Person(const char* name = "peter")
 		: _name(name )
 {
 		cout<<"Person()" <<endl;
 }
 Person(const Person& p)
 		: _name(p._name)
 {
		 cout<<"Person(const Person& p)" <<endl;
 }
 Person& operator=(const Person& p )
 {
 		cout<<"Person operator=(const Person& p)"<< endl;
 if (this != &p)
 	_name = p ._name;
 	return *this ;
 }
 ~Person()
 {
	 cout<<"~Person()" <<endl;
 }
 protected :
 	string _name ; // 姓名
};
 class Student : public Person
 {
 public :
 	Student(const char* name, int num)
 		: Person(name )
 		, _num(num )
 {
		 cout<<"Student()" <<endl;
 }
 Student(const Student& s)
 		: Person(s)
 		, _num(s ._num)
 {
 		cout<<"Student(const Student& s)" <<endl ;
 }
 Student& operator = (const Student& s )
 {
 	cout<<"Student& operator= (const Student& s)"<< endl;
     if (this != &s)
     {
         Person::operator =(s);
        _num = s ._num;
     }
        return *this ;
} 
protected :
    int _num ; //学号
};

子类的析构函数和父类的析构函数构成隐藏，因为他们名字会被编译器统一处理成destructor
~Student()
{
	//Person::~Person();
	cout<< "~Student()"<<endl;
}


子类结束时会自动调用父类的析构函数，不需要显示调用
```



#### 友元关系不能继承,

```
 class Student;
 class Person
 {
 public:
    friend void Display(const Person& p, const Student& s);
 protected:
    string _name; // 姓名
};
 class Student : public Person
 {
 protected:
    int _stuNum; // 学号
};
//基类友元不能访问子类私有和保护成员
void Display(const Person& p, const Student& s)
 {
    cout << p._name << endl;
    cout << s._stuNum << endl;
 }
 
void main()
 {
    Person p;
    Student s;
    Display(p, s);
 }

```



#### 继承静态实例只有一个

#### 复杂菱形继承及菱形虚拟继承

单继承	class S : public A

多继承	class S : public A,public B

菱形继承  问题：数据冗余和二义性

虚拟继承可以解决上述问题 ：virtual

```
								   class Person
									    ⬇	
class Student:virtual public Person              class Teacher:virtual public Person
                    ⬇										⬇
                     class A : public Student,public Teacher
                      
```

内存对象模型

![image-20250618220407557](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250618220407557.png)



```
class A
 {
 public:
 	int _a;
 };
 // class B : public A
 class B : virtual public A
 {
 public:
 	int _b;
 };
 // class C : public A
 class C : virtual public A
 {
 public:
 	int _c;
 };
 class D : public B, public C
 {
 public:
     	int _d;
 };
//输出大小20字节
//虚继承输出大小24字节
```

**虚继承解决数据的冗余性和二义性，在公共区域存放有二义性的数据**

原理：将虚基类对象放到公共位置（visual 下是放到整个对象的尾部），虚基表中存放偏移量，来计算虚基类对象的位置。

虚基表也是存在代码段(常量区)

（菱形虚拟继承）

![image-20250613233026054](C:\Users\LIYUFENG\AppData\Roaming\Typora\typora-user-images\image-20250613233026054.png)



实际中不到万不得已，不要把类的关系设计成菱形继承

总结：

- is-a 继承是一种白箱复用，父类对子类基本透明，但是它一定程度破坏了父类的封装

- has-a 组合是一种黑箱复用，C对D不透明，C保持它的封装

